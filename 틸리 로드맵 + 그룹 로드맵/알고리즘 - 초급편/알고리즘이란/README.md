<h3>알고리즘이란?</h3><blockquote><p>어떠한 문제를 해결하기 위한 일련의 절차나 방법을 공식화한 형태로 표현한 것을 의미한다.</p></blockquote><p>👉 <code><strong>예시</strong></code></p><ul><li>집에서 학교로 가는 길 찾기</li><li>된장찌개 만드는 법</li><li>물건 구매하는<br>&nbsp;ddd</li></ul><h3>📎 알고리즘의 조건</h3><p>👉 <code><strong>입력</strong></code>: 외부에서 제공되는 자료가 0개 이상 있어야 한다.</p><p>👉 <code><strong>출력</strong></code>: 적어도 2개 이상의 서로 다른 결과를 내어야 한다. 즉, 모든 입력에 하나의 출력이 나오면 안된다.</p><p>👉 <code><strong>명확성</strong></code>: 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.</p><p>👉 <code><strong>유한성</strong></code>: 유한번의 명령어를 수행 후 유한 시간 내에 종료한다.</p><p>👉 <code><strong>효율성</strong></code>: 모든 과정은 명백하게 실행(검증 가능)한 것이어야 한다.</p><p><br>&nbsp;dad<br>&nbsp;</p><ul><li>da</li></ul><p>&nbsp;</p><p>dada</p><h3>📎 좋은 알고리즘의 분석 기준</h3><p>👉 <code><strong>정확성</strong></code>: 적당한 입력에 대해서 유한 시간 내에 올바른 답을 산출하는가를 판단한다.</p><p>👉 <code><strong>작업량</strong></code>: 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정한다.</p><p>👉 <code><strong>기억 장소 사용량</strong></code>: 기억 장소 사용량은 메모리 사용량의 뜻으로, 수행에 필요한 저장공간을 가능한 최소화했는가를 판단한다.</p><p>👉 <code><strong>최적성</strong></code>: 그 알고리즘보다 더 적은 연산을 수행하는 알고리즘이 없어야 한다.</p><p><br>&nbsp;</p><h3>📎 코딩 테스트 관련 알고리즘 분류</h3><p>👉 <code><strong>알고리즘</strong></code></p><p>👉 <code><strong>시간/공간 복잡도</strong></code></p><p>👉 <code><strong>점화식과 표기법</strong></code></p><p>👉 <code><strong>in-place와 stable</strong></code></p><p>👉 <code><strong>재귀 함수와 분할 정복</strong></code></p><p>👉 <code><strong>정렬 알고리즘</strong></code></p><ul><li>선택 정렬</li><li>삽입 정렬</li><li>버블 정렬</li><li>계수 정렬</li><li>병합 정렬</li><li>퀵 정렬</li><li>기수 정렬</li><li>힙 정렬</li></ul><p>👉 <code><strong>탐색/검색 알고리즘</strong></code></p><ul><li>BST</li><li>AVL와 Red-Black Tree</li></ul><p>👉 <code><strong>DFS/BFS</strong></code></p><ul><li>깊이 우선탐색(DFS)과 백트래킹</li><li>너비우선탐색(BFS)</li></ul><p>👉 <code><strong>그래프 관련 알고리즘</strong></code></p><ul><li>최소 신장 트리(MST) 관련 알고리즘<ul><li>크루스칼</li><li>프림</li></ul></li><li>최단 경로 관련 알고리즘<ul><li>다익스트라</li><li>벨만-포드</li><li>A* (에이스타)</li><li>플로이드-와샬</li></ul></li><li>기타<ul><li>위상정렬</li><li>Union &amp; Find</li><li>강연결요소</li></ul></li></ul><p>👉 <code><strong>동적계획법(DP)</strong></code></p><p>👉 <code><strong>탐욕법(Greedy)</strong></code></p><p>👉 <code><strong>문자열 관련 알고리즘</strong></code></p><ul><li>문자열 매칭<ul><li>라빈-카프</li><li>KMP</li><li>보이어-무어</li></ul></li></ul><p>&nbsp;</p><h2 style="margin-left:auto;">📌 2. 시간 복잡도와 공간 복잡도</h2><hr><h3 style="margin-left:auto;">📎 알고리즘 계산 복잡도</h3><blockquote><p>알고리즘 계산 복잡도는 <code><strong>시간 복잡도</strong></code>와 <code><strong>공간 복잡도</strong></code>로 평가된다. 따라서 <code><strong>좋은 알고리즘은 실행 기간도 짧고, 저장 공간도 적게 쓰는 알고리즘</strong></code>이다.<br><br>하지만 2가지 모두 만족시키기는 어렵다. 시간과 공간은 반비례적하는 경향이 있으며, 최근 대용량 시스템이 보편화되면서 공간 복잡도보다는 시간 복잡도가 우선이기 때문이다.<br><br>그래서 알고리즘은 <code><strong>시간 복잡도</strong></code>가 중심이된다.</p></blockquote><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 공간 복잡도(Space Complexity)</h3><blockquote><p><code><strong>공간복잡도</strong></code>란 프로그램의 성능을 분석하는 방법 중 하나로, <code><strong>얼마나 저장공간(메모리)를 차지하느냐를 분석하는 방법</strong></code>이다. 하지만 최근에는 컴퓨터 성능의 발달로인해 메모리의 여유 공간이 충분하기 때문에 공간복잡도의 중요성이 많이 줄어들었다.</p></blockquote><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 시간 복잡도(Time Complexity)</h3><blockquote><p><code><strong>시간복잡도</strong></code>란 특정 알고리즘이 <code><strong>어떤 문제를 해결하는데 걸리는 시간</strong></code>을 의미한다. 같은 결과를 가져오는 프로그래밍 소스도 어떻게 작성하느냐에 따라 걸리는 시간이 달라질 수 잇다. 같은 결과를 나타내는 소스 중 가장 시간이 적게 걸리는 소스가 가장 좋은 소스라고 볼 수 있다.</p></blockquote><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 시간 복잡도를 표기하는 방법</h3><blockquote><p>알고리즘 분석 시, 평균성능과 최악의 성능이 가장 많이 활용된다. 하지만 평균을 구하는 세타 표기법이 가장 정확한 것에 비해 알고리즘이 복잡해질수록 평가하기가 어려워서 최악을 구하는 <code><strong>빅오 표기법을 가장 많이 사용</strong></code>한다.</p></blockquote><p style="margin-left:auto;">👉 <code><strong>Big-O(빅-오)</strong></code>: 최악의 입력을 한 상태에서 작업 완료까지 가장 느린 시간을 측정<br>👉 <code><strong>Big-Ω(빅-오메가)</strong></code>: 최적의 입력을 한 상태에서 작업을 완료하는데 가장 빠른 시간을 측정<br>👉 <code><strong>Big-θ(빅-세타)</strong></code>: 여러가지 다른 경우의 수를 입력하여, 총실행시간을 계산하고 시행횟수로 나눠서 평균을 측정</p><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 시간 복잡도 줄이는 법</h3><p style="margin-left:auto;">👉 알고리즘에서 시간복잡도에 가장 큰 영향을 끼치는 것은 <code><strong>반복문</strong></code>이다.<br>👉 해결해야할 문제 또는 이슈에 맞는 적절한 알고리즘을 설계해야한다.<br>👉 각 알고리즘의 형태에 맞는 효율적인 자료구조들을 이용한다면 시간 복잡도를 낮출 수 있다.</p><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 Big-O 표기법의 성능: 수행시간과 연산횟수 기준</h3><figure class="image" style="height:auto;"><img style="aspect-ratio:832/552;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F41c31d13-4c50-45d1-af0d-fa97fa72efee%2F1.png" width="832" height="552"></figure><blockquote><p><code><strong>O(1)</strong></code> &lt; <code><strong>O(log n)</strong></code> &lt; <code><strong>O(n)</strong></code> &lt; <code><strong>O(n * log n)</strong></code> &lt; <code><strong>O(n^2)</strong></code> &lt; <code><strong>O(2^n)</strong></code> &lt; <code><strong>O(n!)</strong></code></p></blockquote><h4 style="margin-left:auto;">👉 <strong>O(1): 상수 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F9999ee5c-8dfa-460a-8a84-2ff18d1e039a%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC38.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">입력 데이터의 크기에 상관없이 문제 해결시 <strong>오직 한단계만 처리하여 일정한 시간이 걸리는 알고리즘</strong>을 나타낸다.</p><p style="margin-left:auto;">ex) <code><strong>스택에서 Push</strong></code>, <code><strong>Pop</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(log n): 로그 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F0d3ce229-ffda-4dcd-b5c6-953c90b165eb%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC44.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;"><strong>입력 데이터의 크기가 커질수록 처리 시간이 로그만큼 짧아지는 알고리즘</strong>이다. 한 번 처리 할 때마다 검색해야하는 데이터의 양이 절반씩 떨어지기 때문이다. 때문에 매우 큰 입력값에서도 큰 영향을 받지 않으며, O(1) 다음으로 가장 빠르고 견고한 알고리즘이다.</p><p style="margin-left:auto;">ex) <code><strong>이진탐색(이진 트리)</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(n): 직선적 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F45bc1d05-6d3f-4310-a7df-7581033d7e55%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC39.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">모든 입력값을 적어도 한 번 이상을 살펴보기 때문에 입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다.</p><p style="margin-left:auto;">ex) <code><strong>for문</strong></code>, <code><strong>최대값</strong></code>, <code><strong>최소값</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(n * log n): 선형 로그 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2Fba0b294e-b015-4586-a4a5-6760bf156ee2%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC41.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">입력 데이터의 크기가 커질수록 처리 시간이 로그(log)만큼 늘어나는 알고리즘이다.</p><p style="margin-left:auto;">ex) <code><strong>퀵정렬</strong></code>, <code><strong>병합 정렬</strong></code>, <code><strong>힙 정렬</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(n^2): 제곱 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F29b6b576-ae03-43ce-8882-da9d6be1a2c2%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC40.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">버블 정렬같은 비효율적인 정렬 알고리즘이 이에 해당한다. 입력 데이터의 크기에 따라 걸리는 시간은 제곱에 비례한다. 따라서 n값이 커지면 실행 시간이 감당할 수 없을 정도로 늘어난다.</p><p style="margin-left:auto;">ex) <code><strong>이중 for문</strong></code>, <code><strong>삽입 정렬</strong></code>, <code><strong>거품 정렬</strong></code>, <code><strong>선택 정렬</strong></code>, <code><strong>루프 구조</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(2^n): 지수 시간</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F528a31d3-420c-4fd8-865e-1b7c33a52fb3%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC42.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">입력 데이터의 크기에 따라 걸리는 시간의 2의 n제곱만큼 비례한다. 보통 문제를 풀기 위한 모든 조합과 방법을 시도할 때 사용된다.</p><p style="margin-left:auto;">ex) <code><strong>피보나치 수열</strong></code></p><h4 style="margin-left:auto;">👉 <strong>O(n!)</strong></h4><figure class="image" style="height:auto;"><img style="aspect-ratio:4200/2550;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2F44500d76-3501-4cc9-a61c-b738e61ee315%2F%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1_%E1%84%89%E1%85%A5%E1%86%AF%E1%84%86%E1%85%A7%E1%86%BC43.jpg" width="4200" height="2550"></figure><p style="margin-left:auto;">가장 느린 알고리즘으로 입력값이 조금만 커져도 계산이 어려워진다.</p><p style="margin-left:auto;"><br><br>&nbsp;</p><h2 style="margin-left:auto;">📌 3. Bog-O 표기법으로 나타낸 복잡도</h2><hr><h3 style="margin-left:auto;">📎 Big-O 자료 구조 별 복잡도</h3><figure class="image" style="height:auto;"><img style="aspect-ratio:1418/1792;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2Fb0eb457b-975c-4082-94a1-2e2df8cb1ffc%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-08%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.29.00.png" width="1418" height="1792"></figure><p style="margin-left:auto;"><br>&nbsp;</p><h3 style="margin-left:auto;">📎 Big-O 정렬 알고리즘 복잡도</h3><figure class="image" style="height:auto;"><img style="aspect-ratio:1414/1154;" src="https://velog.velcdn.com/images%2Falicesykim95%2Fpost%2Faba7bed6-386b-4f63-b165-a6c017e2b01a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-01-08%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.29.50.png" width="1414" height="1154"></figure><p style="margin-left:auto;"><br><br>&nbsp;</p><h2 style="margin-left:auto;">📖 참고</h2><ul><li><a href="https://blog.chulgil.me/algorithm/">https://blog.chulgil.me/algorithm/</a></li><li><a href="https://velog.io/@lisapark6956/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80">https://velog.io/@lisapark6956/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%9E%80</a></li><li><a href="https://codermun-log.tistory.com/235">https://codermun-log.tistory.com/235</a></li><li><a href="https://heestory217.tistory.com/83">https://heestory217.tistory.com/83</a></li><li><a href="https://velog.io/@welloff_jj/Complexity-and-Big-O-notation">https://velog.io/@welloff_jj/Complexity-and-Big-O-notation</a></li><li><a href="https://joontae-kim.github.io/2021/04/15/algorithm-big-O/">https://joontae-kim.github.io/2021/04/15/algorithm-big-O/</a></li></ul><figure class="image image_resized" style="height:8rem;width:8rem;"><img style="aspect-ratio:420/420;" src="https://velog.velcdn.com/images/alicesykim95/profile/9f095ac3-374e-4838-80e9-a6c9d35f9d51/social.png" alt="profile" width="420" height="420"></figure><p><br>&nbsp;</p>